PEP: 230
Title: Warning Framework
Version: $Revision$
Author: guido@python.org (Guido van Rossum)
Status: Draft
Type: Standards Track
Python-Version: 2.1
Status: Incomplete
Post-History: 05-Nov-2000


Abstract

    This PEP proposes a C and Python level API, as well as command
    line flags, to issue warning messages and control what happens to
    them.  This is mostly based on GvR's proposal posted to python-dev
    on 05-Nov-2000, with some ideas (such as using classes to
    categorize warnings) merged in from Paul Prescod's
    counter-proposal posted on the same date.


Motivation

    With Python 3000 looming, it is necessary to start issuing
    warnings about the use of obsolete or deprecated features, in
    addition to errors.  There are also lots of other reasons to be
    able to issue warnings, both from C and from Python code, both at
    compile time and at run time.

    Warnings aren't fatal, and thus it's possible that a program
    triggers the same warning many times during a single execution.
    It would be annoying if a program emitted an endless stream of
    identical warnings.  Therefore, a mechanism is needed that
    suppresses multiple identical warnings.

    It is also desirable to have user control over which warnings are
    printed.  While in general it is useful to see all warnings all
    the time, there may be times where it is impractical to fix the
    code right away in a production program.  In this case, there
    should be a way to suppress warnings.

    It is also useful to be able to suppress specific warnings during
    program development, e.g. when a warning is generated by a piece
    of 3rd party code that cannot be fixed right away, or when there
    is no way to fix the code (possibly a warning message is generated
    for a perfectly fine piece of code).  It would be unwise to offer
    to suppress all warnings in such cases: the developer would miss
    warnings about the rest of the code.

    On the other hand, there are also situations conceivable where
    some or all warnings are better treated as errors.  For example,
    it may be a local coding standard that a particular deprecated
    feature should not be used.  In order to enforce this, it is
    useful to be able to turn the warning about this particular
    feature into an error, raising an exception (without necessarily
    turning all warnings into errors).

    Therefore, I propose to introduce a flexible "warning filter"
    which can filter out warnings or change them into exceptions,
    based on:

    - Where in the code they are generated (per package, module, or
      function)

    - The warning category (warning categories are discussed below)

    - A specific warning message

    The warning filter must be controllable both from the command line
    and from Python code.


APIs For Issuing Warnings

    - To issue a warning from Python:

      sys.warn(message[, category])

      The category argument, if given, must be a warning category
      class (see below); it defaults to warnings.UserWarning.  This
      may raise an exception if the particular warning issued is
      changed into an error by the warnings filter.

    - To issue a warning from C:

      int Py_Warn(char *message, PyObject *category)

      Return 0 normally, 1 if an exception is raised.  The category
      argument must be a warning category class (see below).  When
      Py_Warn() function returns 1, the caller should do normal
      exception handling.  [Question: what about issuing warnings
      during lexing or parsing, which don't have the exception
      machinery available?]


Warnings Categories

    The "warnings" module defines classes representing warning
    categories.  This categorization is useful to be able to filter
    out groups of warnings.  The classes defined in this module have
    no semantics attached to them and are never instantiated -- only
    their names are used for filtering (see the section on the
    warnings filter below).  The following warnings category classes
    are currently defined:

    - Warning -- this is the base class of all warning category
      classes.  A warning category must always be a subclass of this
      class.

    - UserWarning -- the default category for sys.warn()

    - DeprecationWarning -- base category for warnings about deprecated
      features

    - SyntaxWarning -- base category for warnings about dubious
      syntactic features

    Other categories may be proposed during the review period for this
    PEP.


The Warnings Filter

    The warnings filter control whether warnings are ignored,
    displayed, or turned into errors (raising an exception).

    There are three sides to the warnings filter:

    - The data structures used to efficiently determine the
      disposition of a particular Py_Warn() call.

    - The API to control the filter from Python source code.

    - The command line switches to control the filter.

    The warnings filter works in several stages.  It is optimized for
    the (expected to be common) case where the same warning is issued
    from the same place in the code over and over.

    First, the warning filter collects the module and line number
    where the warning is issued; this information is readily available
    through PyEval_GetFrame().

    Conceptually, the warnings filter maintains an ordered list of
    filter specifications; any specific warning is matched against
    each filter specification in the list in turn until a match is
    found; the match determines the disposition of the match.  Each
    entry is a tuple as follows:

      (category, message, module, lineno, action)

    - category is a class (a subclass of warnings.Warning) of which
      the warning category must be a subclass in order to match

    - message is a regular expression that the warning message must
      match

    - module is a regular expression that the module name must match

    - lineno is an integer that the line number where the warning
      occurred must match, or 0 to match all line numbers

    - action is one of the following strings:

        - "error" -- turn matching warnings into exceptions

        - "ignore" -- never print matching warnings

        - "always" -- always print matching warnings

        - "default" -- print the first occurrence of matching warnings
          for each location where the warning is issued

        - "module" -- print the first occurrence of matching warnings
          for each module where the warning is issued

        - "once" -- print only the first occurrence of matching
          warnings

    The Warning class is derived from the built-in Exception class, so
    that to turn a warning into an error we raise category(message).


The Warnings Output Hook

    When the warnings filter decides to issue a warning (but not when
    it decides to raise an exception), it passes the information about
    the function sys.showwarning(message, category, filename, lineno).
    The default implementation of this function writes the warning text
    to sys.stderr, and shows the source line of the filename.


API For Manipulating Warning Filters

    sys.filterwarnings(message, category, module, lineno, action)

    This checks the types of the arguments and inserts them as a tuple
    in front of the warnings filter.

    sys.resetwarnings()

    Reset the warnings filter to empty.

    sys.setupwarnings(args)

    Parse command line options and initialize the warnings filter
    accordingly.  The argument should be sys.argv[1:] or equivalent.
    Unrecognized options raise getopt.error.  The return value is a
    list containing the remaining (non-option) arguments.


Command Line Syntax

    There should be command line options to specify the most common
    filtering actions, which I expect to include at least:

    - suppress all warnings

    - suppress a particular warning message everywhere

    - suppress all warnings in a particular module

    - turn all warnings into exceptions

    I propose the following command line option syntax:

    -Waction[:message[:category[:module[:lineno]]]]

    Where:

    - 'action' is an abbreviation of one of the allowed actions
      ("error", "default", "ignore", "always", "once", or "module")

    - 'message' is a message string; matches warnings whose message
      text is an initial substring of 'message' (matching is
      case-sensitive)

    - 'category' is an abbreviation of a standard warning category
      class name *or* a fully-qualified name for a user-defined
      warning category class of the form [package.]module.classname

    - 'module' is a module name (possibly package.module)

    - 'lineno' is an integral line number

    All parts except 'action' may be omitted, where an empty value
    after stripping whitespace is the same as an omitted value.

    Each -W option results into a call to sys.filterwarnings(); thus
    later -W options override earlier -W options for warnings they
    both match.

    Examples:

    -Werror
        Turn all warnings into errors

    -Wall
        Show all warnings

    -Wignore
        Ignore all warnings

    -Wi:hello
        Ignore warnings whose message text starts with "hello"

    -We::Deprecation
        Turn deprecation warnings into errors

    -Wi:::spam:10
        Ignore all warnings on line 10 of module spam

    -Wi:::spam -Wd:::spam:10
        Ignore all warnings in module spam except on line 10

    -We::Deprecation -Wd::Deprecation:spam
        Turn deprecation warnings into errors except in module spam


Open Issues

    Some open issues off the top of my head:

    - The proposal has all the Python API functions in the sys module,
      except that the warning categories are in the warnings module.
      Perhaps everything should be in the warnings module (like the
      prototype implementation)?  Or perhaps warn() should be promoted
      to a built-in (i.e. in the __builtin__ module)?

    - It's tempting to leave the implementation in Python and add an
      absolute minimal amount of C code, only to make the standard
      warning categories available from C code.  The Py_Warn()
      function could call warnings.warn().  Similarly, the Python
      main() function could collect -W options and pass them to
      warnings.setupwarnings().

    - The prototype implements a third argument to warn():

      warn(message, category=UserWarning, level=1)

      The 'level' argument could be used by wrapper functions written
      in Python, like this:

      def deprecation(message):
          warn(message, DeprecationWarning, level=2)

      This makes the warning refer to the deprecation()'s caller,
      rather than to the source of deprecation() itself (the latter
      would defeat the purpose of the warning message).

    - The proposed command line syntax is ugly (although the simple
      cases aren't so bad: -Werror, -Wignore, etc.).  Anybody got a
      better idea?

    - I'm a bit worried that the filter specifications are too
      complex.  Perhaps filtering only on category and module (not on
      message text and line number) would be enough?

    - There's a bit of confusion between module names and file names.
      The reporting uses file names, but the filter specification uses
      module names.  Maybe it should allow filenames as well?

    - I'm not at all convinced that packages are handled right.

    - Better names for the various API functions?


Implementation

    Here's a prototype implementation:

  http://sourceforge.net/patch/?func=detailpatch&patch_id=102715&group_id=5470


Local Variables:
mode: indented-text
indent-tabs-mode: nil
End:
